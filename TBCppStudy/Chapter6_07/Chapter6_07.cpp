#include <iostream>
#include <typeinfo> // typeid() 등의 함수 사용을 위해 include > 타입 정보를 확인할 수 있음.

using namespace std;

int main()
{
    int x = 5;
    double d = 123.0;

    //cout << x << endl;
    //cout << &x << endl; // & : address-of operator (메모리 주소는 기본적으로 16진수로 출력됨.)
    //cout << (int)&x << endl; // 16진수 메모리 주소를 10진수 정수형으로 캐스팅하여 출력

    // de-reference operator (*) (cs 에서 '레퍼런스'란, '간접적으로 가리키다' 의 어감으로 많이 쓰임. 포인터도 레퍼런스의 일종)
    /*
        포인터가 
        "저쪽 주소에 가면 이 데이터가 있어요" 라고
        간접적으로 가리키기만 한다면,

        de-reference(역참조) 는 
        "그럼 거기에 진짜 뭐가 있는지 내가 들여다볼께"
        라며 직접적으로 접근한다는 의미
    */
    // &x 가 x 변수 메모리 주소라면, "그 메모리 주소가 가리키는 곳에 진짜 뭐가 있는지" 확인하는 게 역참조 연산자 *(&x)! 
    // *&x 라고 써도 됨. 
    // 결국, & 가 메모리 주소를 나타낸다면, 
    // * 는 & 가 가리키는 곳의 값이므로, 둘이 상쇄가 되어서 그냥 x 안에 담긴 값으로 나오는 원리! 
    //cout << *(&x) << endl; 

    // 위에서 확인해 본 메모리 주소 자체를 담는 변수를 '포인터' 라고 함!
    /*
        포인터 기호 * 를 
        1. 타입 옆에 붙일 수 있고, (int* ptr_x)
        2. 변수명 옆에 붙일 수도 있고, (int *ptr_x)
        3. 둘 다 띄울 수도 있고, (int * ptr_x)
        
        여러가지 방법이 있기는 한데,
        가급적 2번 처럼 변수명 옆에 붙이는 걸 권장함.

        왜냐하면, 
        아래 코드와 같이,
        두 개의 포인터 변수를 동시에 선언 및 초기화할 경우,

        int* ptr_x = &x, ptr_y = &x;

        이렇게 타입 옆에 포인터 기호를 붙이면,
        마치 ptr_x 와 ptr_y 가 모두 int* 타입의 포인터 변수로 선언된 것처럼 보이지만,
        실제로는 ptr_x 만 포인터 변수로 선언된 것임.

        그래서 ptr_y = &x 를 입력하면 에러를 발생시킴.

        따라서, 아래와 같이 헷갈리지 않도록
        가급적 변수명 옆에 포인터 기호를 붙이는 것을 권장함!
        int *ptr_x = &x, *ptr_y = &x;
    */
    //typedef int* pint; // 물론, '정수형 포인터 타입' 처럼, 포인터를 하나의 타입 별칭으로 선언할 경우, 타입 옆에 붙이는 것도 가능함. 
    //pint ptr_x = &x, ptr_y = &x; // 위와 같이 포인터 타입을 하나의 타입 별칭으로 선언할 경우, 포인터 기호를 변수명 옆에 각각 붙여주지 않더라도 문제가 없음! 
    // > 그러나, 이렇게 사용하는 경우는 많지 않고, 대체로 아래와 같이 각각의 변수에 포인터 기호를 붙여쓰는 경우가 더 많음.
    int* ptr_x = &x;
    double *ptr_d = &d; // double 타입 변수의 메모리 주소를 할당하려면, 포인터 변수의 타입도 double 로 선언해야 함.

    // 포인터 변수에는 그냥 '메모리 주소값'이 담기는데, int, double 등의 타입을 추가로 선언해주는 이유가 뭘까?
    // de-referencing 을 할 때, 해당 메모리 공간에 저장된 데이터를 int 로 가져와야 할 지, double 로 가져와야 할 지 등을
    // 정하기 위해서 선언하는 것임!
    cout << ptr_x << endl;
    cout << *ptr_x << endl; // ptr_x 가 int 타입 포인터 변수로 선언되었기 때문에, de-referencing 으로 가져오는 값을 int 타입으로 가져옴.

    cout << ptr_d << endl;
    cout << *ptr_d << endl;

    cout << typeid(ptr_x).name() << endl; // int * 로 출력됨

    // 그렇다면 포인터 변수의 메모리 사이즈는 어떻게 될까?
    // 정답은 int 타입 포인터든, double 타입 포인터든, 포인터 변수에는 '메모리 주소값'만 들어 있으므로,
    // 모든 타입의 포인터 변수는 메모리 사이즈가 동일함!
    // 이때, x86(32 bits) 아키텍쳐는 메모리 주소값이 4 bytes 로 저장되지만,
    // x64(64 bits) 아키텍쳐는 메모리 주소값이 8 bytes 로 저장됨.
    // 왜냐하면, x64 아키텍쳐로 빌드한 프로그램이 더 많은 메모리를 사용할 수 있으므로,
    // 더 많은 메모리의 주소들을 전부 표현하려면 주소를 표현하는 데이터의 양이 그만큼 더 늘어날 수밖에 없겠지!
    cout << sizeof(x) << endl; // 4 bytes
    cout << sizeof(d) << endl; // 8 bytes
    cout << sizeof(&x) << " " << sizeof(ptr_x) << endl; // 4 bytes 4 bytes
    cout << sizeof(&d) << " " << sizeof(ptr_d) << endl; // 4 bytes 4 bytes > 모든 메모리 주소값은 x86 아키텍쳐 기준 4 bytes 로 동일함!

    return 0;
}

/*
    왜 이딴 짓을 하는가?
    포인터가 왜 필요한건가?

    1. 가장 큰 이유는 배열 때문!
    배열의 길이가 100만 개라고 쳐보자.

    그렇다면, 어떤 함수에 매개변수로
    배열 요소 100만개를 다 복사해서 전달할 것인가?

    그건 너무 비효율적이기 때문에,
    배열의 첫 번째 요소의 주소와 배열의 길이만 전달하면,

    "이 배열에는 첫 번째 요소의 주소에 저장된 공간과
    그 옆 붙어있는 메모리 공간 100만 개에 저장된 데이터가 담겨있습니다~"

    라는 정보만 전달해주면 훨씬 더 간편하게 배열을 관리할 수 있음.


    2. 변수를 넘겨주고 전달할 때마다.
    메모리 공간에 담긴 값을 매번 복사해주는 게 불편하기 때문!

    굳이 메모리 공간을 새로 할당해서 동일한 값을 복사할 게 아니라.
    해당 메모리 공간의 주소만 전달해주면,

    그 주소를 보고 찾아간 메모리 공간의 값만
    바로 참조할 수 있으면 되니 메모리 사용이 훨씬 적음!
*/