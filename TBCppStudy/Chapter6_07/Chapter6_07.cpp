#include <iostream>

using namespace std;

int main()
{
    int x = 5;

    //cout << x << endl;
    //cout << &x << endl; // & : address-of operator (메모리 주소는 기본적으로 16진수로 출력됨.)
    //cout << (int)&x << endl; // 16진수 메모리 주소를 10진수 정수형으로 캐스팅하여 출력

    // de-reference operator (*) (cs 에서 '레퍼런스'란, '간접적으로 가리키다' 의 어감으로 많이 쓰임. 포인터도 레퍼런스의 일종)
    /*
        포인터가 
        "저쪽 주소에 가면 이 데이터가 있어요" 라고
        간접적으로 가리키기만 한다면,

        de-reference(역참조) 는 
        "그럼 거기에 진짜 뭐가 있는지 내가 들여다볼께"
        라며 직접적으로 접근한다는 의미
    */
    // &x 가 x 변수 메모리 주소라면, "그 메모리 주소가 가리키는 곳에 진짜 뭐가 있는지" 확인하는 게 역참조 연산자 *(&x)! 
    // *&x 라고 써도 됨. 
    // 결국, & 가 메모리 주소를 나타낸다면, 
    // * 는 & 가 가리키는 곳의 값이므로, 둘이 상쇄가 되어서 그냥 x 안에 담긴 값으로 나오는 원리! 
    //cout << *(&x) << endl; 

    // 위에서 확인해 본 메모리 주소 자체를 담는 변수를 '포인터' 라고 함!
    /*
        포인터 기호 * 를 
        1. 타입 옆에 붙일 수 있고, (int* ptr_x)
        2. 변수명 옆에 붙일 수도 있고, (int *ptr_x)
        3. 둘 다 띄울 수도 있고, (int * ptr_x)
        
        여러가지 방법이 있기는 한데,
        가급적 2번 처럼 변수명 옆에 붙이는 걸 권장함.

        왜냐하면, 
        아래 코드와 같이,
        두 개의 포인터 변수를 동시에 선언 및 초기화할 경우,

        int* ptr_x = &x, ptr_y = &x;

        이렇게 타입 옆에 포인터 기호를 붙이면,
        마치 ptr_x 와 ptr_y 가 모두 int* 타입의 포인터 변수로 선언된 것처럼 보이지만,
        실제로는 ptr_x 만 포인터 변수로 선언된 것임.

        그래서 ptr_y = &x 를 입력하면 에러를 발생시킴.

        따라서, 아래와 같이 헷갈리지 않도록
        가급적 변수명 옆에 포인터 기호를 붙이는 것을 권장함!
        int *ptr_x = &x, *ptr_y = &x;
    */
    //typedef int* pint; // 물론, '정수형 포인터 타입' 처럼, 포인터를 하나의 타입 별칭으로 선언할 경우, 타입 옆에 붙이는 것도 가능함. 
    //pint ptr_x = &x, ptr_y = &x; // 위와 같이 포인터 타입을 하나의 타입 별칭으로 선언할 경우, 포인터 기호를 변수명 옆에 각각 붙여주지 않더라도 문제가 없음! 
    // > 그러나, 이렇게 사용하는 경우는 많지 않고, 대체로 아래와 같이 각각의 변수에 포인터 기호를 붙여쓰는 경우가 더 많음.
    int *ptr_x = &x, *ptr_y = &x;

    return 0;
}