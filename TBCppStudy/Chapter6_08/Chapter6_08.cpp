#include <iostream>

using namespace std;

void printArray(int array[])
{
    cout << sizeof(array) << endl;
}

int main()
{
    // 사이즈가 5개인 정적 배열 선언 및 초기화
    int array[5] = { 9, 7, 5, 3, 1 };

    cout << array[0] << " " << array[1] << endl; // 정적 배열의 각 요소에 접근하여 출력 > 배열의 각 요소 출력

    // 배열 변수의 메모리 주소와 배열의 첫 번째 요소의 메모리 주소가 같네?
    /*
        사실, array (배열 변수)는
        실제로는 배열이 아니라 '포인터' 임!

        포인터 변수라면 주소값을 저장하고 있겠지?
        정확히 어떤 주소값이냐 하면, 
        위 5개의 요소들을 연이어 담고 있는 메모리 공간들에서,
        첫 번째 요소를 담는 메모리 공간의 주소값을 저장하고 있음!
    */
    cout << array << endl; // 배열 변수 자체를 출력 > 메모리 주소값 출력 > 아, 배열이 저장된 메모리의 주소값이 출력되었구나!
    cout << &(array[0]) << endl; // 배열의 첫 번째 요소의 메모리 주소값 출력

    // 그러면, 배열 변수가 '포인터 변수'라고 했으니까,
    // 거기에 담긴 주소값을 de-referencing 도 할 수 있겠네? 당연히 가능!
    cout << *array << endl; // 배열 변수는 배열의 첫 번째 요소의 주소값이 담겨있는 포인터 변수이므로, de-referencing 하면 당연히 배열의 첫번째 요소인 9가 출력됨.


    // 문자열 배열도 동일하게 적용되는지 확인해보자
    char name[] = "jackjack";

    // 마찬가지로, 문자열 배열 변수 name (= 'char 타입 포인터 변수' 라고 봐도 됨.) 에는 
    // 문자열 배열의 첫 번째 요소가 저장된 메모리 공간의 주소값을 담고 있으므로, 
    // de-referencing 하면 첫 번째 문자 j 가 출력됨.
    cout << *name << endl;

    int* ptr = array; // 이번에는 아예 포인터 변수를 선언한 뒤, 거기에 배열 변수 array 에 저장된 주소값을 할당해보자.
    cout << ptr << endl; // 역시 array 에 저장된 메모리 주소와 동일한 주소값이 출력됨.
    cout << *ptr << endl; // array 에 저장된 메모리 주소를 de-referencing 한 것과 마찬가지이므로, 9가 출력됨.


    /*
        그렇다면 배열과 포인터 변수가 완벽히 동일한가?

        그렇지는 않다.
        배열은 사용자의 편의를 위해
        몇 가지 추가 기능을 더 제공하고 있다.
    */
    // sizeof() 로 배열의 크기를 측정하면, 예외적으로 배열은 포인터 변수임에도 불구하고,
    // array 에 담긴 전체 요소의 메모리 주소값의 사이즈가 합쳐져서 반환됨.
    cout << sizeof(array) << endl; // 4 bytes * 5 = 20 bytes
    cout << sizeof(ptr) << endl; // 4 bytes (기본적으로 모든 타입의 포인터 변수에 저장된 메모리 주소값은 x86 아키텍쳐 기준 4 bytes 로 동일하다고 했었지?)

    return 0;
}