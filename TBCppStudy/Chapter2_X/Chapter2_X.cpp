#include <iostream>

void my_function()
{

}

int main()
{
    // void 타입은 메모리를 차지하지 않기 때문에, void 타입의 변수를 선언할 수 없다!
    //void my_void;

    int i = 123;
    float f = 123.456f;

    // *가 붙으면 주소, 즉 포인터를 의미함.
    void* my_void;

    // & (앰퍼샌드)를 붙이면 주소가 된댔지?
    // 따라서, &i 는 '정수형 변수의 주소값',
    // &f 는 '실수형 변수의 주소값'
    /*
        여기서 중요한 점!

        데이터 타입마다 크기가 다르더라도,
        "데이터가 저장된 메모리 공간을 가리키는 주소값",
        이 주소값을 표현하는 데이터의 양은 동일함!

        왜? 데이터가 몇 개의 메모리를 차지하던 간에,
        메모리 주소값은 각 데이터의 "첫 번째 메모리만" 가리키기 때문!
        첫 번째 메모리 공간만 가리키는 주소로만 표현된다면,
        데이터 타입이 뭐가 됐든 주소값을 표현하는 데이터의 양은 동일하겠지!

        그래서, 결국 &i 의 주소값과 &f 의 주소값은
        데이터 타입이 달라도, 결국 주소값을 표현하는 데이터 양 자체는 동일하므로,
        동일한 void* 타입으로 캐스팅(형변환)을 할 수 있는 것!

        -> 이런 식으로 void 타입이 쓸모가 없어보여도,
        주소값을 저장하는 변수의 타입으로 void* 을 사용하는 경우가 많다!
    */
    my_void = (void*)&i;
    my_void = (void*)&f;

    return 0;
}
