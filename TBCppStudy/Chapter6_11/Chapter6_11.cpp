#include <iostream>

using namespace std;

int main()
{
    /*
        정적으로 배열을 생성할 경우, 
        1,000,000 개 정도의 int 타입 배열을 선언하면,
        약 4 bytes * 1,000,000 = 4 mb 정도의 용량을 차지함.

        이 정도는 그렇게까지 큰 메모리는 아님에도 불구하고,
        프로그램을 빌드 및 실행하면 알 수 없는 에러가 발생함.

        이 원인이 뭘까?
        정적으로 배열을 생성하면,
        해당 배열은 'stack memory' 에 할당됨.

        그런데 이 스택 메모리(자동 메모리)는
        용량이 작은 편이기 때문에,
        4 mb 정도의 메모리를 차지하는 배열을 할당할 수 없었던 것임!

        반면, '힙 메모리(자유 메모리)'
        는 동적으로 메모리를 할당할 수 있는 메모리 영역인데
        스택보다 훨씬 용량이 크다!

        그래서, 메모리 동적 할당을 잘 사용하는 방법을 익혀야
        더 큰 메모리를 사용하는 변수들을
        자유자재로 다룰 수 있겠지!
    */
    //int array[1000000];

    /*
        new 키워드
        
        c++ 에서 메모리를 동적으로 할당하는 방법!

        아래와 같이, 
        int 타입의 4 bytes 메모리를
        힙 메모리 영역에 할당하고 싶다면,

        new int 를 사용해서 할당할 수 있음.

        이때, new 는 할당된 메모리 공간의 주소값을 반환하므로,
        이 주소값은 포인터 변수에 저장해뒀다가 사용하면 되겠지!

        c 언어에서 malloc() 과 동일한 역할!
    */
    /*
        이때, 만약 다른 프로그램들이 메모리를 모두 점유하고 있어서,
        new 키워드로 남아있는 메모리 공간을 할당받는 데에 실패한다면,
        프로그램이 죽어버리도록 놔둘수도 있겠지만,

        에러를 발생시키지 않고,
        프로그램이 이어서 계속 실행되도록 밀어붙이고 싶다면?

        new 키워드 뒤에
        (std::nothrow) 를 붙여주면,
        new 키워드로 메모리 할당에 실패하더라도 에러를 발생시키지 않고,
        그냥 nullptr 을 포인터 변수에 할당한 채 계속 프로그램을 진행시킴.
    */
    int* ptr = new (std::nothrow) int;
    *ptr = 7; // 이렇게 de-referencing 으로 해당 메모리 공간에 값을 초기화할 수 있음!
    
    // 아래처럼 힙 메모리 영역 할당과 동시에 초기화하는 것도 가능
    // int* ptr = new int(7);
    // int* ptr = new int{ 7 };

    // new 키워드에 의한 메모리 할당에 실패할 경우,
    // 위에서 설명했듯이 포인터 변수에 nullptr 을 반환하므로,
    // 포인터에 대해 nullptr 이 아닌 유의미한 주소값을 갖는지 한 번 체크해줘야 함!
    if (ptr)
    {
        cout << ptr << endl; // 힙 메모리 영역에 할당된 주소
        cout << *ptr << endl; // de-referencing 으로 역참조한 실제 값
    }
    else
    {
        // 메모리 할당에 실패했다는 메시지 출력 > 좀 더 친절한 프로그래밍!
        cout << "Could not allocate memory" << endl;
    }

    /*
        힙 메모리 영역을 동적으로 할당하는 방법을 배웠다면,
        더 중요한 '할당받은 메모리를 OS 에게 돌려주는'
        즉, '메모리 동적 해제'를 할 줄도 알아야겠지!

        그냥 'delete' 키워드로 메모리를 해제하면 됨!

        c 언어에서 free() 와 같은 역할!

        근데, 사실 현재 코드 맥락에 한해서는
        delete 를 사용하지 않더라도 메모리가 자동 반납됨.

        왜냐하면, OS 가
        일전에 어디에 메모리를 얼만큼 줬었다를
        다 기억하고 있기 때문에,
        
        프로그램이 종료되면 알아서 나눠줬던 메모리들을
        수거해가도록 되어있음.

        다만, delete 를 사용하면
        '말씀하시기 전에 제가 알아서 반납하겠습니다'
        라고 프로그램이 종료되기 전에 먼저 메모리를 반납할 뿐임.
    */
    delete ptr;

    // 메모리 반납 후 포인터 변수를 출력해본다면?
    /*
        메모리 주소값 자체는 포인터 변수에 기록되어 있어
        해당 메모리 공간을 반납한다고 하더라도,
        포인터 변수에 저장된 주소값 자체는 그대로 유지됨.

        그러나, de-referencing 을 통해
        해당 메모리 주소값을 따라가서 저장된 값을 확인해보면,
        이전에 할당된 정수값 7이 아닌,
        엉뚱한 값이 들어가 있는 걸 볼 수 있음.

        마치 군대 간 사이에 가족들이 이사를 해서
        내가 알던 똑같은 우리집 주소를 따라 같더니
        생판 남이 우리집에 살고있는 것과 같은 상황...
    */
    cout << "After delete" << endl;
    //cout << ptr << endl; // 힙 메모리 영역에 할당된 주소는 이전과 동일하게 나옴.
    //cout << *ptr << endl; // de-referencing 으로 역참조했더니 알 수 없는 값이 나옴

    // 위와 같은 상황을 방지하기 위해 포인터 변수를 nullptr 값으로 초기화할 수 있음.
    // nullptr 이란, '이 포인터 변수가 갖고있는 주소값은 아무런 의미가 없는 주소값이에요. null 값이에요.' 라는 의미!
    // 그 다음, 해당 포인터 변수에 대해 nullptr 체크를 해서,
    // 유의미한 주소값을 갖는 경우에만 해당 포인터 변수에 대해 de-referencing 을 해주는 것!
    // 그러나, 이런 기법을 사용하지 않더라도, '스마트 포인터' 라는 개념을 나중에 배우면 더 쉽게 포인터를 초기화할 수 있음!
    ptr = nullptr;
    if (ptr != nullptr)
    {
        cout << ptr << endl;
        cout << *ptr << endl;
    }

    return 0;
}