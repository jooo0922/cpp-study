#include <iostream>

using namespace std;

int main()
{
    const int num_rows = 3;
    const int num_columns = 5;

	// 이중 반복문으로 행렬 출력하기
	for (int row = 0; row < num_rows; ++row)
	{
		for (int col = 0; col < num_columns; ++col)
		{
			cout << "[" << row << "]" << "[" << col << "]" << "\t"; // "\t" 는 탭 문자를 의미함.
		}

		cout << endl;
	}

	cout << endl;

	// 위와 같은 행렬을 다차원 배열로 구현해보자
	// 2차원 배열을 선언하는 방법
	// row-major (행 우선 행렬을 표현할 수 있는 2차원 배열) <-> column-major (반대 개념으로 열 우선 행렬이 있음.)
	// 맨 첫 번째 배열의 갯수를 num_rows 로 넣느냐 num_columns 로 넣느냐에 따라
	// 열 우선 / 행 우선 행렬 여부가 결정될 뿐, 내부적으로는 둘 다 동일한 2차원 배열에 불과함.
	//int array[num_rows][num_columns]; 

	// 2차원 배열 초기화 방법 (단순무식하게 각 요소마다 값을 초기화할 수도 있음.)
	// array[0][0] = 1;
	// array[0][1] = 2;
	// ...

	// 다음과 같이 한꺼번에 초기화하는 것도 가능.
	// 2차원 배열이 1 depth 는 row 를 표현하므로, row 단위로 2 depth 배열을 묶어서 나열함.
	// -> 이래서 row-major 이라고 불리는 구나!
	//int array[num_rows][num_columns] = 
	//{
	//	{1, 2, 3, 4, 5},		// row 0
	//	{6, 7, 8, 9, 10},		// row 1
	//	{11, 12, 13, 14, 15}	// row 2
	//};


	// 2차원 배열 초기화를 좀 더 쉽게 할 수 있는 방법들
	//int array[][num_columns] = // num_rows (즉, 1 depth 의 개수는 생략 가능 > 왜냐면 아래와 같이 초기화하면 rows 는 3개구나 라고 뻔히 예측이 가능하기 때문!)
	//{
	//	{1, 2, },				// row 0 > 1차원 배열과 마찬가지로, 초기화하지 않은 값에 대해서는 [num_rows]로 지정해 준 개수만큼 0으로 자동 초기화함!
	//	{6, 7, 8, 9, 10},		// row 1
	//	{11, 12, 13, 14, 15}	// row 2
	//};

	int array[num_rows][num_columns] = { 0 }; // 2차원 배열의 요소들을 전부 0으로 초기화할 수도 있음.

	int array2[5][4][3]; // 3차원 배열 선언하는 방법도 동일한 원리 적용. > 이런 식으로 3차원 이상의 다차원 배열은 딥러닝에서 텐서를 표현할 때 사용된다고 함.

	// 초기화한 2차원 배열을 이중 for 문으로 출력해보기 > 2차원 배열은 주로 행렬 표현에 많이 사용됨
	for (int row = 0; row < num_rows; ++row)
	{
		for (int col = 0; col < num_columns; ++col)
		{
			cout << array[row][col] << "\t"; // "\t" 는 탭 문자를 의미함.

			// 2차원 배열 각 요소의 메모리 주소도 10진수 정수형으로 형변환해서 찍어보자
			// int 타입 배열이므로, 4 bytes 간격으로 메모리 공간 주소가 할당되어 있는 것을 볼 수 있음.
			// 그런데, 첫 번째 row 까지의 요소들의 메모리 주소 출력이 끝나고,
			// 두 번째 row 의 첫 요소 메모리 주소가 출력된 곳을 확인해보니,
			// 첫 번째 row 의 마지막 요소 메모리 주소와 마찬가지로 4 bytes 차이가 나는구나!
			// 아, 결국 2차원 배열안의 모든 요소들은 4 bytes 간격으로 일렬로 쭉 메모리 상에 저장되어 있는 배열에 불과한데,
			// 마치 2차원 배열인 것 처럼, 각 row 들을 접어서 표현한 것에 불과한 것이구나! > 내부적으로는 그냥 일렬로 쭉 이어진 1차원 배열에 불과함!
			// > 이런 개념들이 나중에 동적 메모리 할당 시 아주 유용하게 사용됨.
			//cout << (int)&array[row][col] << "\t";
		}

		cout << endl;
	}


	return 0;
}