#include <iostream>

using namespace std;

// 문자열 심볼릭 상수를 함수의 반환 타입으로도 선언할 수 있음.
const char* getName()
{
    return "Jack Jack";
}

int main()
{
    //char name[] = "Jack Jack";

    // 문자열은 배열이고, 배열이 사실상 포인터와 같다면, 이렇게 포인터 변수에 문자열 리터럴을 바로 넣을 수 있을까?
    // > 이렇게 초기화하는 건 불가능!
    // 포인터 변수에는 오로지 '주소값'만이 할당될 뿐, 문자열 리터럴 자체는 할당될 수 없음
    //char* name = "Jack Jack"; 

    /*
        문자열 심볼릭 상수

        그럼에도 불구하고, char* 타입의 포인터 변수에 const 를 붙여주면,
        문자열 리터럴을 기호적인 상수처럼 사용할 수 있도록 해줘서
        
        컴파일러가 특별히, 
        "Jack Jack"이라는 문자열 배열을 메모리에 저장하고,
        name 이라는 포인터 변수를 통해서 이 문자열 배열이 저장된 메모리 공간에
        access 할 수 있도록 도와주는 것!

       그런데 수상한 점은,
       아무리 문자열 심볼릭 상수니 뭐니 희한한 걸 만들어놨다 해도,
       const char* 타입 변수는 결국 포인터 변수에 불과한데,
       어떻게 스트림 출력을 했을 때 문자열 리터럴이 출력되는 걸까?

       상식적으로 포인터 변수를 출력하면 주소값이 출력되어야 하는 것 아닌가?

       이런 괴상한 일이 발생하는 이유는,
       C++ 의 스트림 출력 연산자 '<<' 가
       const char* 타입의 포인터 변수를 만나면
       해당 포인터가 가리키는 메모리 공간에 저장된 '문자열 리터럴'을 출력하도록
       내부적으로 함수가 오버로딩 되어있기 때문임!

       만약, 이 문자열 리터럴이 저장된 메모리 공간의 주소값을 출력하고 싶다면,
       (uintptr_t)name 와 같이 10진수 주소 타입으로 형변환해서 출력하면 됨!
    */
    const char* name = "Jack Jack";
    const char* name2 = "Jack Jack"; // 또 다른 const char* 타입 포인터 변수를 변수명만 다르게 선언함.
    const char* name3 = getName();

    //cout << name << endl; // "Jack Jack"

    /*
        동일한 내용의 문자열 리터럴을 할당받은 
        const char* 타입 포인터 변수 두 개를 스트림으로 출력해봤더니 
        두 변수가 동일한 메모리 주소를 가리키고 있네?
        
        이는 컴파일러가 

        "야 너네는 보니까 초기화된 문자열 리터럴이 같네. 
        너네 둘은 그냥 같은 메모리 공간을 가리키도록 해!"
        
        이런 느낌으로 처리했기 때문임!
    */

    //cout << (uintptr_t)name << endl;
    //cout << (uintptr_t)name2 << endl;
    //cout << (uintptr_t)name3 << endl; // 문자열 리터럴의 내용이 같다면, 역시 동일한 메모리 주소를 출력할 것임.

    int int_arr[5] = { 1, 2, 3, 4, 5 }; // 정수 타입 배열 (포인터)
    char char_arr[] = "Hello, World!"; // 문자열 배열 (포인터)
    const char* name4 = "Jack Jack"; // 문자열 심볼릭 상수 > 얘도 내부적으로 처리하는 원리 상으로는 문자열 배열로 봐도 됨. (포인터)
    
    // 배열은 포인터와 거의 같다고 했으면서, 
    // 왜 문자열 배열만 cout 으로 출력하면 문자열 리터럴이 나오는거지?
    // 이것도 그냥 cout 스트림 출력이 문자열 배열을 만나면 특별하게 처리한다고만 이해해야 함. 
    // > 그냥 얘내는 예외적으로 이렇게 작동하는구나 하고 외워야 함.
    cout << int_arr << endl; // 00F3FD44 (메모리 주소 출력)
    cout << char_arr << endl; // "Hello, World!" (문자열 출력)
    cout << name4 << endl; // "Jack Jack" (문자열 출력)

    // 그렇다면, 만약 스트림 출력에서
    // char 타입 문자 변수의 주소를 & 주소연산자로 출력하려고 한다면?
    // cout 은 문자열이나 문자 변수를 만날 경우, 
    // '아 얘는 문자니까 문자로 처리해야겠다' 하고 예외적으로 특별하게 처리한다고 했지? 
    // 그래서 문자 변수의 주소값을 넣어도, '문자 변수'로 인식을 해버려서
    // 주소값에서 공백문자(null)가 나올 때까지 계속 문자로써 출력하려다보니
    // 알 수 없는 특수문자들이 출력되는 등 예상치 않은 결과가 나타남.
    char c = 'Q';
    cout << &c << endl;
    
    return 0;
}