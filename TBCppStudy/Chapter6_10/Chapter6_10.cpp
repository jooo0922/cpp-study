#include <iostream>

using namespace std;

// 문자열 심볼릭 상수를 함수의 반환 타입으로도 선언할 수 있음.
const char* getName()
{
    return "Jack Jack";
}

int main()
{
    //char name[] = "Jack Jack";

    // 문자열은 배열이고, 배열이 사실상 포인터와 같다면, 이렇게 포인터 변수에 문자열 리터럴을 바로 넣을 수 있을까?
    // > 이렇게 초기화하는 건 불가능!
    // 포인터 변수에는 오로지 '주소값'만이 할당될 뿐, 문자열 리터럴 자체는 할당될 수 없음
    //char* name = "Jack Jack"; 

    /*
        문자열 심볼릭 상수

        그럼에도 불구하고, char* 타입의 포인터 변수에 const 를 붙여주면,
        문자열 리터럴을 기호적인 상수처럼 사용할 수 있도록 해줘서
        
        컴파일러가 특별히, 
        "Jack Jack"이라는 문자열 배열을 메모리에 저장하고,
        name 이라는 포인터 변수를 통해서 이 문자열 배열이 저장된 메모리 공간에
        access 할 수 있도록 도와주는 것!

       그런데 수상한 점은,
       아무리 문자열 심볼릭 상수니 뭐니 희한한 걸 만들어놨다 해도,
       const char* 타입 변수는 결국 포인터 변수에 불과한데,
       어떻게 스트림 출력을 했을 때 문자열 리터럴이 출력되는 걸까?

       상식적으로 포인터 변수를 출력하면 주소값이 출력되어야 하는 것 아닌가?

       이런 괴상한 일이 발생하는 이유는,
       C++ 의 스트림 출력 연산자 '<<' 가
       const char* 타입의 포인터 변수를 만나면
       해당 포인터가 가리키는 메모리 공간에 저장된 '문자열 리터럴'을 출력하도록
       내부적으로 함수가 오버로딩 되어있기 때문임!

       만약, 이 문자열 리터럴이 저장된 메모리 공간의 주소값을 출력하고 싶다면,
       (uintptr_t)name 와 같이 10진수 주소 타입으로 형변환해서 출력하면 됨!
    */
    const char* name = "Jack Jack";
    const char* name2 = "Jack Jack"; // 또 다른 const char* 타입 포인터 변수를 변수명만 다르게 선언함.
    const char* name3 = getName();

    cout << name << endl; // "Jack Jack"

    /*
        동일한 내용의 문자열 리터럴을 할당받은 
        const char* 타입 포인터 변수 두 개를 스트림으로 출력해봤더니 
        두 변수가 동일한 메모리 주소를 가리키고 있네?
        
        이는 컴파일러가 

        "야 너네는 보니까 초기화된 문자열 리터럴이 같네. 
        너네 둘은 그냥 같은 메모리 공간을 가리키도록 해!"
        
        이런 느낌으로 처리했기 때문임!
    */

    cout << (uintptr_t)name << endl;
    cout << (uintptr_t)name2 << endl;
    cout << (uintptr_t)name3 << endl; // 문자열 리터럴의 내용이 같다면, 역시 동일한 메모리 주소를 출력할 것임.

    return 0;
}