#include <iostream>

using namespace std;

int main()
{
    int* ptr = nullptr;

    // 포인터에 대한 포인터 > 이중 포인터를 만들 수도 있음!
    // 자료구조 알고리즘 구현 시 많이 사용해봤었지?
    int** ptrptr = nullptr; // 포인터에 대한 포인터인데, 원래 변수의 타입은 int 다! 라고 이해하면 됨.

    int value = 5;
    ptr = &value;

    ptrptr = &ptr; // 즉, <특정 포인터 변수(ptr)에 저장된 메모리 주소값>이 저장된 메모리 주소값이 ptrptr 에 할당됨! 

    // 포인터 변수에 담긴 주소값, 포인터 변수 de-referencing, <포인터 변수에 담긴 주소값>이 저장된 메모리의 주소값 각각 출력
    cout << ptr << " " << *ptr << " " << &ptr << endl;

    // 이중 포인터 변수에 담긴 주소값, 이중 포인터 변수 de-referencing, <이중 포인터 변수에 담긴 주소값>이 저장된 메모리의 주소값 각각 출력
    cout << ptrptr << " " << *ptrptr << " " << &ptrptr << endl;

    // 이중 포인터 변수를 이중으로 de-referencing 한 값 출력
    /*
        좀 풀어서 설명하자면, 
        **ptrptr 은 *(*ptrptr) 과 같고,
        이는 *(ptr) 과 같음.

        *ptr 은 value 와 같으므로,
        결과적으로 이중 de-referencing 의 값은
        value 에 할당된 값인 5가 출력될 것임!
    */
    cout << **ptrptr << endl;

    // 실제로 3중, 4중 포인터까지도 사용할 수는 있지만, 거의 사용할 일은 없고,
    // 이중 포인터의 경우 2차원 배열로 행렬 구현 시 주로 사용됨.
    const int row = 3; // 2차원 행렬의 행 수
    const int col = 5; // 2차원 행렬의 열 수

    // 정적 2차원 배열로 행렬을 생성함.
    const int s2da[row][col] =
    {
        // 1차원 배열 3개가 나열되어 있는 형태로도 볼 수 있음.
        {1, 2, 3, 4, 5},
        {6, 7, 8, 9, 10},
        {11, 12, 13, 14, 15}
    };

    // 동일한 2차원 배열 행렬을 동적 배열로 생성해보자 (동적 배열 생성하는 방법 배웠었지?)
    // 행렬의 '행'을 표현하는 1차원 배열을 new 키워드로 힙 메모리에 동적으로 할당!
    // 이때, 할당된 각 배열의 첫 번째 요소의 메모리 주소값을 각 int* 타입 포인터 변수에 반환받아 저장했었지?
    // 동적 배열 생성 방법은 https://github.com/jooo0922/cpp-study/blob/main/TBCppStudy/Chapter6_12/Chapter6_12.cpp 참고!
    int* r1 = new int[col] {1, 2, 3, 4, 5};
    int* r2 = new int[col] {6, 7, 8, 9, 10};
    int* r3 = new int[col] {11, 12, 13, 14, 15};

    // 동적 배열로 행렬을 만들려면, '2차원 배열'을 '동적'으로 생성해야겠지?
    // 1차원 배열들과 마찬가지로 new 키워드로 힙 메모리에 배열을 할당한 뒤, 첫 번째 요소의 주소값을 받아오면 되겠지만,
    // 2차원 배열은 1차원 배열들을 요소로 나열한 배열이고, 각 1차원 배열들 또한 포인터 변수에 주소값이 저장되어 있는 형태이므로,
    // 2차원 배열은 <1차원 배열 포인터 변수들>이 저장된 메모리 공간의 주소값들을 나열한 '이중 포인터'로 선언해야겠지!
    // 그래서, 2차원 배열은 <1차원 배열 포인터 변수들>을 나열한 배열이므로, 
    // new 키워드로 힙 메모리를 할당할 때, 배열의 타입도 int*[] 형태로 선언되고 있음! 
    int** rows = new int* [row] {r1, r2, r3};

    // 이제 2차원 동적 배열을 이중 for 문으로 순회해서 출력해보자
    for (int r = 0; r < row; r++)
    {
        for (int c = 0; c < col; c++)
        {
            cout << rows[r][c] << " ";
        }
        cout << endl; // 행 출력이 끝날 때마다 줄바꿈 처리
    }

    // new 키워드로 동적으로 생성한 배열들은 항상 delete 키워드로 메모리를 반납해줘야 한다고 했었지?
    // 2차원 동적 배열의 경우, 1차원 배열의 메모리들부터 먼저 반납해주면 됨!
    delete[] r1;
    delete[] r2;
    delete[] r3;
    delete[] rows;

    return 0;
}