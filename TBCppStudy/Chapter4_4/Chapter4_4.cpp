#include <iostream>

// int 타입의 두 매개변수를 더해서 반환한다면,
// 반환값을 auto 타입으로 지정하면 알아서 타입추론을 해줌!!
auto add(int x, int y)
{
    return x + y;
}

// 그러나, auto 는 매개변수를 double, int 등 아무거나 받더라도
// 자동으로 타입추론하여 계산하는 목적으로는 쓰일 수 없다. 
// 즉, 매개변수에는 auto 를 적용해서 사용할 수 없다!
// 그러나, 매개변수를 아무런 타입으로 받아서 알아서 타입 추론하여 계산되도록 하는 기능이 있는데,
// 이것은 강의 후반부에 나올 'template' 이라는 개념을 알아야 함!! > 단점은 사용이 조금 어려울 수 있음.
auto add(double x, double y)
{
    return x + y;
}

// 트레일링(자취를 남긴다. 꼬리를 남긴다.)
// 아래와 같이 매개변수 옆에 "-> 변수타입" 형태로 반환타입을 명시하는 것.
// 굳이 앞에 auto 로 넣어놓고 int 를 명시해놓는 이유가 있나?
auto add2(int x, int y) -> int
{
    return x + y;
}

// 아래와 같이 단어의 길이가 다른 타입을 명시해놓고 함수명을 들여쓰기로 맞추는 것보다
// auto 로 함수명 정렬을 맞추고, 트레일링으로 반환타입을 명시하는 게 좀 더 보기좋다? 는 정도의 장점이 있음..
int    add2(int x, int y);
double add2(int x, int y);

auto add2(int x, int y) -> int;
auto add2(int x, int y) -> double;

int main()
{
    using namespace std;

    /*
        auto 를 변수의 타입으로 지정하면,
        타입을 상황에 따라 스스로 결정하게 만드는 것을 '형 추론(타입추론)' 이라고 한다.

        c++11 에 도입된 아주 편리한 기능!
        
        단, auto 는 변수에 초기화된 값을 기반으로 타입을 추론하기 때문에,
        변수를 '선언'만 하고, 초기화하지 않으면 타입 추론을 할 수가 없다.

        즉, 
        auto a;
        이렇게는 못쓴다는 소리!

        물론, 가급적 중요한 변수의 타입은
        프로그래머가 정확히 인지하고서 타입을 명시해놓는 게 좋겠지!
    */
    auto a = 123; // 변수에 마우스를 갖다대면 int 로 컴파일러가 타입을 추론해놓음.
    auto d = 123.0;
    auto c = 1 + 2.0;

    // 이렇게 하면, 함수 add() 의 반환 타입이 뭔지 매번 확인할 필요 없이
    // auto 타입이 result 의 타입을 자동으로 추론해줘서 아주 편리함!
    auto result = add(1, 2);

    return 0;
}
