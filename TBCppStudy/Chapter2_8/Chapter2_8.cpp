#include <iostream>

int main()
{
    using namespace std;

    // 3.14 같이 변하지 않는 값 자체를 리터럴 상수 (literal constants) 라고 함.
    float pi = 3.14f;
    //int i = 12324u; // 정수값 뒤에도 u 라는 것을 붙일 수 있는데, 이게 unsigned 라는 뜻임.
    int i = (unsigned int)12324; // 근데 끝에 u를 붙이면 가독성이 떨어져서, 차라리 캐스팅으로 확실하게 보이게 함.
    
    unsigned int n = 5u;
    long n2 = 5L; // long 타입 정수형에 넣는 값 뒤에도 L 을 붙일 수 있음.
    double d = 6.0e-10; // 6.0 * 10^-10

    // Decimal(10진수): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...
    // Octal(8진수): 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 13, ...
    // Hexa(16진수): 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, ...

    // 16진수와 8진수는 다른 코드에서 의외로 많이 사용되니 반드시 알아둘 것.
    // 0011 1010 1111 1111 같은 2진수를
    // 3A7F 같은 16진수로 표기하기 훨씬 간단하고 쉬워서 많이 사용됨.

    int x = 012; // 십진수 앞에 0을 붙이면 8진수라는 의미
    cout << x << endl; // 팔진수에서 12는 십진수로 변환하면 10에 해당해서 콘솔에는 10으로 출력됨.
    int x1 = 0xF; // 십진수 앞에 0x 를 붙이면 16진수라는 의미
    cout << x1 << endl; // 16진수에서 F 는 십진수로 변환하면 15에 해당해서 콘솔에는 15로 출력됨.

    // Binary Literal (c++ 14 부터 이진수 값을 직접 입력할 수 있게 됨.)
    int x2 = 0b1010; // 이진수 앞에 0b 를 붙여서 표시
    cout << x2 << endl; // 이진수 1010 은 십진수로 변환하면 10이 나옴.

    // 긴 이진수 값을 표기할 경우, c++ 14 부터는 이진수 사이에 ' 를 삽입해도 컴파일러가 무시하게 되어있음. 
    // 즉, 긴 이진수를 읽기 쉽게 구분할 수 있는 구분자를 넣을 수 있게 됨. (이진수 외에 10진수에도 사용 가능!)
    int x3 = 0b1010'1111'1010; 
    cout << x3 << endl;

    // 리터럴 상수를 그냥 옆에 주석으로 설명해줘도 되는데, 
    // 딱 봤을때 리터럴 상수가 눈에 잘 안들어옴.
    // 또 만약, 해당 리터럴 상수가 반복되서 사용되어야 할 경우도 있는 것!
    // 이런 상수를 magic number 라 하는데, 이를 코드 상에 그대로 남겨놓는 건 별로 좋지 않음.
    int num_items = 123;
    int price = num_items * 10; // 10 is ...

    // 이럴 때 사용하는 게 Symbolic Constants(기호적 상수) 임. 리터럴 상수와 대비되는 개념. 
    // 그냥 const 에 담아두고 쓰는거임.
    const int price_per_item = 10;
    int price2 = num_items * price_per_item;

    return 0;
}
