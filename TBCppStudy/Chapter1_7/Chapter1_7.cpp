#include <iostream>

using namespace std; // standard template library 네임스페이스 가져오기 (이제 네임스페이스 중복 선언 불필요)

int main()
{
	// 중괄호 안에 선언된 변수는 중괄호 밖을 넘어가면 사라진다. (메모리가 해제된다)
	int x(0); // int x = 0; 이렇게 초기화를 해도 됨. 표현방식의 차이. > 이렇게 메모리에 할당된 변수는 현재 스코프의 블록을 벗어나면 메모리에서 사라져버린다!
	//int x = 1; // 같은 스코프에서 두 개의 변수가 동일한 식별자(변수명)을 가지면 당연히 문제가 발생하겠지. 동일한 식별자로 서로 다른 메모리 공간을 식별하려고 하는 거니까!

	// 앰퍼샌드 연산자(주소 연산자)로 현재 바깥쪽 블록내의 변수 x 의 "주소값"을 콘솔에 출력해보자
	cout << x << " " << &x << endl;

	{
		// 이렇게 썡뚱맞게 중괄호가 추가되어도 되느냐? 된다!
		// 얘의 역할은 영역(스코프)를 분리해주는 역할!
		
		// 얘는 왜 같은 변수명인데 에러가 안날까?
		// 스코프가 다르기 때문에 같은 변수명이더라도, 이 블록 내의 변수 x 가 할당된 메모리는 이 블록 내에서만 존재하기 때문!
		//int x = 1;

		// 로컬 스코프에서 새로운 변수 x 를 선언하지 않고, 기존의 변수 x 에 값을 재할당
		// 이럴 경우, 콘솔에 찍히는 변수 x 는 모두 같은 메모리 공간의 주소값으로 찍힘. 즉, 모두 같은 메모리 공간을 가리키고 있음을 의미!
		x = 1;

		// 마찬가지로 앰퍼샌드 연산자로 안쪽 블록의 변수 x 의 "주소값"을 콘솔에 출력해보자
		// 변수명이 똑같더라도, 실제 변수가 할당된 메모리 공간의 주소값이 서로 다름!
		cout << x << " " << &x << endl;

		// 또한, 로컬 스코프에서 선언된 변수 x 는
		// 로컬 스코프를 벗어나는 순간 스택 메모리(고정 메모리 영역)에서 해제됨
	}

	cout << x << " " << &x << endl;

	{
		int x = 2;
	}

	return 0;
}