#include <iostream>

using namespace std;

class Mother
{
public:
	int m_i;

	// 자식 클래스의 생성 순서를 확인하기 위해 
	// 부모 클래스의 생성자 함수를 추가함
	
	// 이때, 자식 클래스 생성자의 멤버 초기화 리스트 문법에서
	// 부모 클래스 생성자를 호출해서 간접적으로 부모 클래스의 멤버를 초기화하기 위해
	// 부모 클래스 생성자에 입력 매개변수를 추가해서 생성자 함수를 오버로딩함!
	// 이럴 경우, 기본 생성자가 사라져버림.
	// 예전에는 C++ 에서는 항상 default constructor 가 아닌 생성자를 하나라도 구현하면,
	// default constructor 를 반드시 코드로 명시해줘야 했었음!
	// 그러나, 요즘에는 아래와 같이 매개변수들의 기본값을 '= 0' 형태로 명시해주면,
	// 기본 생성자를 같이 구현한 것과 마찬가지로 되어서 훨씬 편해짐! 
	Mother(const int& i_in = 0)
		: m_i(i_in)
	{
		cout << "Mother construction " << endl;
	}
};

// derived class (= 유도된 클래스. 자식 클래스)
class Child : public Mother 
{
public:
	double m_d;

public:
	Child()
		// 그러나, 유독 멤버 초기화 리스트 문법으로는 부모 클래스의 멤버를 초기화할 때면 컴파일 에러가 발생함
		// 이 문제 원인은 유도된 클래스(자식 클래스)의 생성 순서와 관련이 있다!
		//: m_i(1024)

		// 사실, 자식 클래스 생성자 호출 시점에 부모 클래스 생성자가 먼저 호출될 수 있었던 이유는,
		// 아래와 같이 멤버 초기화 리스트 문법에 부모 클래스 생성자 함수를 호출하는 코드가 내부적으로 숨어있던 것!
		// 우리가 이 코드를 명시적으로 작성하지 않더라도, 컴파일러가 자동으로 이렇게 처리해주는 것!
		// 그렇기 때문에, 어떻게 보면 자식 클래스에서 부모 클래스의 멤버를 간접적으로 초기화하는 것이 가능하긴 함!
		// 아래와 같이 Mother() 생성자에 초기화할 인자값을 전달해주면 되니까!
		: Mother(1024), m_d(1.0)
	{
		// 이처럼 클래스 인스턴스 포인터 this 또는 영역 표시 연산자 :: 을 이용해서
		// 부모 클래스의 public 멤버에 접근하여 '재할당'하는 것은 얼마든지 가능함.
		/*this->m_i = 10;
		Mother::m_i = 1024;*/

		cout << "Child construction " << endl;
	}
};

int main()
{
	// 이렇게 자식 클래스 인스턴스를 생성하는 시점에
	// 생성자 함수의 생성 순서가 어떻게 되는지 확인해보자!
	/*
		Mother construction
		Child construction

		콘솔에는 위 순서대로 찍힌다.

		즉, 부모 클래스 생성자 함수가 먼저 호출되고,
		그 다음에 자식 클래스 생성자 함수가 호출된다.

		따라서, 부모 클래스 생성자 함수 호출되는 시점에
		부모 클래스 내의 멤버들의 값을 '초기화'할 수 있고,

		그 다음에 자식 클래스 생성자 함수가 호출되는 시점에
		생성자 함수의 구현부(body) 내에서 m_i = 1 과 같이 '재할당' 할 수 있는 것임!

		즉, 부모 클래스의 생성자가 먼저 호출된다면,
		부모 클래스의 멤버들은 당연히 부모 클래스 생성자의 멤버 초기화 리스트에서
		먼저 초기화되도록 보장하는 것이 더 타당한 것이지!

		나중에 호출되는 자식클래스에서
		굳이 부모 클래스의 멤버를 초기화할 이유도 없고,
		그럴 자격이나 권한도 막아놓는 게 더 타당한 것이겠지!

		대신, 자식 클래스는 부모 클래스 멤버에 대해 '초기화'할 자격은 없지만,
		생성자 함수 body 내에서 '재할당' 하는 것은 얼마든지 가능함!

		왜냐? 이미 초기화된 변수의 값을 변경하는 것(= 재할당)은
		부모 클래스의 멤버라고 하더라도 public 으로 접근 가능하다면,
		어디서 재할당하고 변경하든지 상관 없으니까!
	*/
	Child c1;

    return 0;
}