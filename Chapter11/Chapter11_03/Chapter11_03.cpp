#include <iostream>

using namespace std;

class Mother
{
public:
	int m_i;

	// 자식 클래스의 생성 순서를 확인하기 위해 
	// 부모 클래스의 생성자 함수를 추가함
	Mother()
		: m_i(1)
	{
		cout << "Mother construction " << endl;
	}
};

// derived class (= 유도된 클래스. 자식 클래스)
class Child : public Mother 
{
public:
	double m_d;

public:
	Child()
		// 그러나, 유독 멤버 초기화 리스트 문법으로는 부모 클래스의 멤버를 초기화할 때면 컴파일 에러가 발생함
		// 이 문제 원인은 유도된 클래스(자식 클래스)의 생성 순서와 관련이 있다!
		//: m_i(1024)
		: m_d(1.0)
	{
		// 이처럼 클래스 인스턴스 포인터 this 또는 영역 표시 연산자 :: 을 이용해서
		// 부모 클래스의 public 멤버에 접근하여 '재할당'하는 것은 얼마든지 가능함.
		this->m_i = 10;
		Mother::m_i = 1024;

		cout << "Child construction " << endl;
	}
};

int main()
{
	// 이렇게 자식 클래스 인스턴스를 생성하는 시점에
	// 생성자 함수의 생성 순서가 어떻게 되는지 확인해보자!
	/*
		Mother construction
		Child construction

		콘솔에는 위 순서대로 찍힌다.

		즉, 부모 클래스 생성자 함수가 먼저 호출되고,
		그 다음에 자식 클래스 생성자 함수가 호출된다.

		따라서, 부모 클래스 생성자 함수 호출되는 시점에
		부모 클래스 내의 멤버들의 값을 '초기화'할 수 있고,

		그 다음에 자식 클래스 생성자 함수가 호출되는 시점에
		생성자 함수의 구현부(body) 내에서 m_i = 1 과 같이 '재할당' 할 수 있는 것임!

		즉, 부모 클래스의 생성자가 먼저 호출된다면,
		부모 클래스의 멤버들은 당연히 부모 클래스 생성자의 멤버 초기화 리스트에서
		먼저 초기화되도록 보장하는 것이 더 타당한 것이지!

		나중에 호출되는 자식클래스에서
		굳이 부모 클래스의 멤버를 초기화할 이유도 없고,
		그럴 자격이나 권한도 막아놓는 게 더 타당한 것이겠지!

		대신, 자식 클래스는 부모 클래스 멤버에 대해 '초기화'할 자격은 없지만,
		생성자 함수 body 내에서 '재할당' 하는 것은 얼마든지 가능함!

		왜냐? 이미 초기화된 변수의 값을 변경하는 것(= 재할당)은
		부모 클래스의 멤버라고 하더라도 public 으로 접근 가능하다면,
		어디서 재할당하고 변경하든지 상관 없으니까!
	*/
	Child c1;

    return 0;
}