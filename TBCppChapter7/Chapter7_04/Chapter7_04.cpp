#include <iostream>

using namespace std;

// 매개변수가 포인터 변수로 선언된 함수 > 주소에 의한 인수 전달
void foo(const int* ptr, int* ptr2)
{
    /*
        포인터 변수의 de-referencing, 
        포인터 변수에 들어있는 주소값, 
        포인터 변수의 주소값이 담긴 메모리의 주소값(이하 '포인터 변수 자체의 주소값' 으로 통일) 

        세 개를 출력해 봄.
    */
    cout << *ptr << " " << ptr << " " << &ptr << endl;

    // const 포인터 변수로 선언된 매개변수는 참조변수와 마찬가지로,
    // const 에 의해 de-referencing 을 통한 값 변경이 불가함 -> 함수의 '입력값' 역할
    //*ptr = 10;

    /*
        다만, const 포인터 변수로 선언된 매개변수더라도,
        해당 포인터 변수의 '주소값'을 변경하는 것은 가능함!

        이를 막으려면, 해당 입력 변수를 const int* const ptr 로 작성해주면,
        포인터 매개변수에 담긴 주소값 조차도 불변으로 만들 수 있기는 함.

        그러나, 포인터 매개변수는 어찌보면 
        현재 함수 내의 '로컬 변수'로 선언된 것에 불과하여,
        이 로컬 변수의 주소값이 바뀐다고 하더라도 외부 변수에 영향을 주지 않음.

        다만, de-referencing 을 통한 실제 값을 변경하는 경우에만
        외부 변수의 값에 영향을 주기 때문에,

        보통은 const int* ptr
        형태로 입력변수를 선언하는 경우가 대부분임.
    */
    int x = 1;
    ptr = &x;

    // 포인터 변수로 선언된 매개변수 또한, 
    // de-referencing 을 통해 외부 포인터 변수가 가리키는 메모리에 저장된 값을 변경할 수 있음!
    // > 참조에 의한 전달과 마찬가지로 함수의 '출력값' 역할을 할 수 있음!
    *ptr2 = 10;
}

int main()
{
    int value = 5;

    cout << value << " " << &value << endl;

    int* ptr = &value;

    int* ptr2 = &value;

    // 외부에서 선언한 포인터 변수 자체의 주소값도 확인
    // -> 함수의 매개변수로 선언된 포인터 변수 자체의 주소값과 다름!
    // -> 말 그대로, 외부 포인터 변수에 할당된 '주소값'만 복사되어 전달된 것이고, 매개변수는 아예 새로운 변수가 메모리 공간에 할당된 것!
    cout << &ptr << endl; 

    // 매개변수가 포인터 변수로 선언된 함수에 주소에 의한 인수 전달 방법 두 가지
    foo(ptr, ptr2); // 1. 포인터 변수에 주소값을 할당하여 간접 선언하여 전달
    foo(&value, ptr2); // 2. 주소값을 직접 전달

    // 함수 내부에서 de-referencing 을 통해 변경된 값을 외부 포인터 변수로 확인 가능!
    cout << value << endl;

    return 0;
}