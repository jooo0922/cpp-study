#include <iostream>
#include <cmath> // sin(), cos() 함수 사용을 위해 포함

using namespace std;

/*
    참조에 의한 전달

    함수 매개변수를 참조변수로 선언하면,
    함수 호출부에서 인자로 전달한 변수 자체의 reference 가
    매개변수로 넘어오게 되므로,

    해당 매개변수의 값을 함수 내부에서 변경할 경우,
    외부에서 전달된 변수의 값을 수정할 수 있게 됨! 
*/
void addOne(int& y)
{
    // 참조변수로 선언된 매개변수 y 의 주소값과
    // 외부에서 인자로 전달된 변수 x 의 주소값이 동일함! > 변수 x 자체가 넘어왔구나!
    cout << y << " " << &y << endl;

    y = y + 1;
}

/*
    매개변수 degrees 는 값에 의한 전달,
    매개변수 sin_out, cos_out 은 참조에 의한 전달!

    따라서, sin_out 과 cos_out 매개변수의 값을 해당 함수 내에서 경우,
    외부에서 전달된 변수의 값에도 영향을 주겠구나! 라고 파악해야 됨!

    이때, degrees 매개변수는 사실상 함수 내부에서 '읽기' 목적으로 사용되는 '입력값' 역할을 하지만,
    sin_out, cos_out 매개변수는 반환값의 개수가 1개로 제한되는 c++ 함수의 한계 상,
    출력하고자 하는 값들을 참조변수에 덮어씌워주는 역할을 하는 '출력값' 역할을 함.

    보통 같은 매개변수라고 할지라도, 위와 같이 역할이 다르게 때문에,
    
    보통 많이들 사용하는 컨벤션이
    
    '입력값' 역할을 하는 변수는 const 변수로 선언하여 불변으로 설정하고, 
    매개변수 리스트의 앞쪽에 선언함.

    -> 이때, 입력값이 const 로 선언되면 어차피 값을 변경하지 못하기 때문에,
    똑같이 참조변수(&)로 선언하더라도 괜찮음. 

    오히려, 매개변수에 '값을 복사하지 않아도 된다' 는 점에서
    메모리 성능에서 더 이점을 취할 수 있는 코딩 스타일!
    
    반면, '출력값' 역할을 하는 변수는 참조변수(&)으로 선언하여
    함수 외부에서 전달된 변수의 값을 '(덮어)쓰기', 즉, 변경할 수 있도록 하고,
    매개변수 리스트의 뒷쪽에 선언함.
*/
// 특정 degree 각도에 대한 sin, cos 값을 계산하는 함수
void getSinCos(const double& degrees, double& sin_out, double& cos_out)
{
    // static 변수로 선언함으로써, 함수 호출될 때마다 매번 메모리에 할당되는 것이 아니라,
    // 함수 최초 호출 시에 정적 메모리에 해당 변수의 메모리 공간을 할당하고, 값을 초기화한 다음,
    // 이후 함수 호출부터는 정적 메모리 공간에 올라가있는 값을 참조하여 재사용함. 
    // 이런 식으로, 자주 사용되는 심볼릭 상수나 값은 static 변수로 선언하여 사용하는 경우도 많음.
    static const double pi = 3.141592 / 180.0;

    // 이 함수에서 사용되는 라디안 각 변수처럼 
    // 한 번 계산되고 나면 더 이상 변경되지 않는 변수들은 const 를 붙여서 불변으로 박제시켜 놔야
    // 나중에 코딩할 때 실수가 적어짐!
    const double radians = degrees * pi;

    // 함수 내부에서 외부로부터 전달된 참조변수의 값을 수정하고 있음!
    // -> 함수 외부로부터 전달된 변수에도 영향을 주겠군!
    sin_out = std::sin(radians);
    cos_out = std::cos(radians);
}

/*
    매개변수가 참조변수로 선언될 경우, 
    리터럴 값을 전달하지 못한다는 단점을 해결하려면,

    1. 참조변수(&) 기호를 빼버려서 그냥 일반 매개변수로 바꾸던지
    2. 참조변수인 매개변수를 const 를 붙여서 불변으로 박제하던지 해야 함.

    물론, 2번 방법은
    해당 함수 내에서 매개변수를 변경하지 않는다는 전제하에!
*/
//void foo(int& x)
void foo(const int& x) // 사실, 이렇게 'const 참조변수' 형태가 c++ 함수 매개변수를 선언할 때 가장 많이 사용하는 방식임!
{
    cout << x << endl;
}

/*
    포인터 변수에 대한 레퍼런스 전달 시,
    함수의 매개변수를 똑같이 참조변수로 선언하면 되는데,
    다만 '포인터 타입의' 참조변수를 선언한다고 생각하면 쉬움.

    즉, 'int*' 타입의 참조변수를 선언한다면,
    int*& 로 선언하면 되겠지?

    그러면 외부에서 전달된 포인터 변수 자체가
    참조변수로 선언된 매개변수를 통해 해당 함수 안으로 그대로 들어오게 됨.
*/
//void foo(int*& ptr)

// 이렇게 int 타입 포인터 변수에 대한 별칭(사용자 정의 타입)을 따로 지정해놓으면, 
// 더 가독성있게 포인터 변수에 대한 참조변수를 선언할 수 있음!
typedef int* pint; 
void foo(pint& ptr)
{
    // 참조변수로 선언된 매개변수 ptr 의 주소값과
    // 외부에서 전달된 포인터 변수 ptr 의 주소값이 일치함 > 아, 포인터 변수 자체가 그대로 들어온 거구나!
    cout << ptr << " " << &ptr << endl;
}
    
int main()
{
    int x = 5;
 
    // 방금 선언된 변수 x 의 값과 주소값 출력
    cout << x << " " << &x << endl;

    // 참조변수로 선언된 매개변수 자리에 변수 x 를 argument(인자)로 전달
    addOne(x);

    // addOne() 함수 내부 로직에 의해 변경된 변수 x 의 값 확인
    cout << x << " " << &x << endl;

    // 참조변수인 getSinCos() 함수의 매개변수 자리에 전달할 sin, cos 외부변수 선언
    double sin(0.0);
    double cos(0.0);

    // 특정 degree 각도에 대한 sin, cos 값을 계산하는 함수라면, 계산된 sin, cos 값을 모두 반환해준다면 좋겠지만,
    // c++ 함수는 1개의 값에 대해서만 반환이 가능하다는 한계점이 존재함. 
    // 이럴 경우, 계산된 값을 직접 반환하기 보다, 여러 개의 외부 변수를 참조변수로 선언된 매개변수 자리에 전달함으로써,
    // 함수 내부에서 직접 외부 변수의 값을 변경하는 방식을 많이 사용함.
    getSinCos(30.0, sin, cos);

    // getSinCos() 함수 내부에서 변경된 값을 출력해보기
    cout << sin << " " << cos << endl;


    // 매개변수가 참조변수로 선언될 경우, 리터럴 값을 전달하지 못한다는 단점이 있음!
    //foo(6);


    // 포인터 변수에 대한 레퍼런스를 전달하기
    int y = 5;
    //int* ptr = &y;
    pint ptr = &y; // int* 타입 포인터 변수에 대한 별칭으로 더 가독성있게 포인터 변수를 선언할 수 있음!

    // 포인터 변수 ptr 에 담긴 값(= 변수 y에 대한 주소값)과 포인터 변수 ptr 자체의 주소값 출력
    cout << ptr << " " << &ptr << endl;

    // 포인터 변수 ptr 을 참조변수로 전달하기
    foo(ptr);

    return 0;
}